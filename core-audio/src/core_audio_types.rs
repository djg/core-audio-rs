use audio_channel_layout::AudioChannelLayoutRef;
use ffi;
use std::{fmt, mem, ops, slice};

/// This struct represents a continuous range of values.
pub type AudioValueRange = ffi::AudioValueRange;

//==============================================================================
// AudioValueTranslation

// TODO

//==============================================================================
// AudioBuffer

ffi_type_stack! {
    type CType = ffi::AudioBuffer;
    /// Holds a buffer of audio data.
    pub struct AudioBuffer;
    /// A reference to a borrowed buffer of audio data.
    pub struct AudioBufferRef;
}

impl AudioBufferRef {
    /// The number of interleaved channels in the buffer.
    pub fn num_channels(&self) -> usize {
        let ab: &ffi::AudioBuffer = unsafe { &*self.as_ptr() };
        ab.mNumberChannels as _
    }
}

impl ops::Deref for AudioBufferRef {
    type Target = [u8];

    fn deref(&self) -> &Self::Target {
        unsafe {
            let ab: &ffi::AudioBuffer = &*self.as_ptr();
            slice::from_raw_parts(ab.mData as *const _, ab.mDataByteSize as _)
        }
    }
}

impl ops::DerefMut for AudioBufferRef {
    fn deref_mut(&mut self) -> &mut [u8] {
        unsafe {
            let ab: &ffi::AudioBuffer = &*self.as_ptr();
            slice::from_raw_parts_mut(ab.mData as *mut _, ab.mDataByteSize as _)
        }
    }
}

//==============================================================================
// AudioBufferList

//==============================================================================
// Audio Formats

#[cfg(feature = "deprecated")]
pub type AudioSampleType = ffi::AudioSampleType;
#[cfg(feature = "deprecated")]
pub type AudioUnitSampleType = ffi::AudioUnitSampleType;

#[derive(Clone, Copy, Debug, PartialEq)]
/// A four char code indicating the general kind of data in the stream.
pub enum AudioFormat {
    /// Linear PCM, uses the standard flags.
    LinearPcm,
    /// AC-3, has no flags.
    Ac3,
    /// AC-3 packaged for transport over an IEC 60958 compliant digital
    /// audio interface. Uses the standard flags.
    _60958Ac3,
    /// Apples implementation of IMA 4:1 ADPCM, has no flags.
    AppleIma4,
    /// MPEG-4 Low Complexity AAC audio object, has no flags.
    Mpeg4Aac,
    /// MPEG-4 CELP audio object, has no flags.
    Mpeg4Celp,
    /// MPEG-4 HVXC audio object, has no flags.
    Mpeg4Hvxc,
    /// MPEG-4 TwinVQ audio object type, has no flags.
    Mpeg4TwinVq,
    /// MACE 3:1, has no flags.
    Mace3,
    /// MACE 6:1, has no flags.
    Mace6,
    /// ÂµLaw 2:1, has no flags.
    ULaw,
    /// aLaw 2:1, has no flags.
    ALaw,
    /// QDesign music, has no flags
    Qdesign,
    /// QDesign2 music, has no flags
    Qdesign2,
    /// QUALCOMM PureVoice, has no flags
    Qualcomm,
    /// MPEG-1/2, Layer 1 audio, has no flags
    MpegLayer1,
    /// MPEG-1/2, Layer 2 audio, has no flags
    MpegLayer2,
    /// MPEG-1/2, Layer 3 audio, has no flags
    MpegLayer3,
    /// A stream of `IOAudioTimeStamps`, uses the `IOAudioTimeStamp flags` (see IOKit/audio/IOAudioTypes.h).
    TimeCode,
    /// A stream of MIDIPacketLists where the time stamps in the
    /// MIDIPacketList are sample offsets in the stream.
    ///
    /// The `sample_rate` field is used to describe how time is passed
    /// in this kind of stream and an AudioUnit that receives or
    /// generates this stream can use this sample rate, the number of
    /// frames it is rendering and the sample offsets within the
    /// MIDIPacketList to define the time for any MIDI event within
    /// this list. It has no flags.
    MidiStream,
    /// A "side-chain" of Float32 data that can be fed or generated by an AudioUnit
    /// and is used to send a high density of parameter value control information.
    /// An AU will typically run a ParameterValueStream at either the sample rate of
    /// the AudioUnit's audio data, or some integer divisor of this (say a half or a
    /// third of the sample rate of the audio). The Sample Rate of the ASBD
    /// describes this relationship. It has no flags.
    ParameterValueStream,
    /// Apple Lossless, the flags indicate the bit depth of the source material.
    AppleLossless,
    /// MPEG-4 High Efficiency AAC audio object, has no flags.
    Mpeg4AacHe,
    /// MPEG-4 AAC Low Delay audio object, has no flags.
    Mpeg4AacLd,
    /// MPEG-4 AAC Enhanced Low Delay audio object, has no flags. This
    /// is the formatID of the base layer without the SBR
    /// extension. See also kAudioFormatMPEG4AAC_ELD_SBR
    Mpeg4AacEld,
    /// MPEG-4 AAC Enhanced Low Delay audio object with SBR extension
    /// layer, has no flags.
    Mpeg4AacEldSbr,
    Mpeg4AacEldV2,
    /// MPEG-4 High Efficiency AAC Version 2 audio object, has no flags.
    Mpeg4AacHeV2,
    /// MPEG-4 Spatial Audio audio object, has no flags.
    Mpeg4AacSpatial,
    /// The AMR Narrow Band speech codec.
    Amr,
    /// The AMR Wide Band speech codec.
    AmrWb,
    /// The format used for Audible audio books. It has no flags.
    Audible,
    /// The iLBC narrow band speech codec. It has no flags.
    Ilbc,
    /// DVI/Intel IMA ADPCM - ACM code 17.
    DviIntelIma,
    /// Microsoft GSM 6.10 - ACM code 49.
    MicrosoftGsm,
    /// This format is defined by AES3-2003, and adopted into MXF and
    /// MPEG-2 containers and SDTI transport streams with SMPTE specs
    /// 302M-2002 and 331M-2000. It has no flags.
    Aes3,
    /// Enhanced AC-3, has no flags.
    EnhancedAc3,
    /// Free Lossless Audio Codec, the flags indicate the bit depth of
    /// the source material.
    Flac,
    /// Opus codec, has no flags.
    Opus,
    /// Unknown four char code.
    Unknown(ffi::AudioFormatID),
}

impl From<ffi::AudioFormatID> for AudioFormat {
    fn from(x: ffi::AudioFormatID) -> Self {
        use AudioFormat::*;
        match x {
            ffi::kAudioFormatLinearPCM => LinearPcm,
            ffi::kAudioFormatAC3 => Ac3,
            ffi::kAudioFormat60958AC3 => _60958Ac3,
            ffi::kAudioFormatAppleIMA4 => AppleIma4,
            ffi::kAudioFormatMPEG4AAC => Mpeg4Aac,
            ffi::kAudioFormatMPEG4CELP => Mpeg4Celp,
            ffi::kAudioFormatMPEG4HVXC => Mpeg4Hvxc,
            ffi::kAudioFormatMPEG4TwinVQ => Mpeg4TwinVq,
            ffi::kAudioFormatMACE3 => Mace3,
            ffi::kAudioFormatMACE6 => Mace6,
            ffi::kAudioFormatULaw => ULaw,
            ffi::kAudioFormatALaw => ALaw,
            ffi::kAudioFormatQDesign => Qdesign,
            ffi::kAudioFormatQDesign2 => Qdesign2,
            ffi::kAudioFormatQUALCOMM => Qualcomm,
            ffi::kAudioFormatMPEGLayer1 => MpegLayer1,
            ffi::kAudioFormatMPEGLayer2 => MpegLayer2,
            ffi::kAudioFormatMPEGLayer3 => MpegLayer3,
            ffi::kAudioFormatTimeCode => TimeCode,
            ffi::kAudioFormatMIDIStream => MidiStream,
            ffi::kAudioFormatParameterValueStream => ParameterValueStream,
            ffi::kAudioFormatAppleLossless => AppleLossless,
            ffi::kAudioFormatMPEG4AAC_HE => Mpeg4AacHe,
            ffi::kAudioFormatMPEG4AAC_LD => Mpeg4AacLd,
            ffi::kAudioFormatMPEG4AAC_ELD => Mpeg4AacEld,
            ffi::kAudioFormatMPEG4AAC_ELD_SBR => Mpeg4AacEldSbr,
            ffi::kAudioFormatMPEG4AAC_ELD_V2 => Mpeg4AacEldV2,
            ffi::kAudioFormatMPEG4AAC_HE_V2 => Mpeg4AacHeV2,
            ffi::kAudioFormatMPEG4AAC_Spatial => Mpeg4AacSpatial,
            ffi::kAudioFormatAMR => Amr,
            ffi::kAudioFormatAMR_WB => AmrWb,
            ffi::kAudioFormatAudible => Audible,
            ffi::kAudioFormatiLBC => Ilbc,
            ffi::kAudioFormatDVIIntelIMA => DviIntelIma,
            ffi::kAudioFormatMicrosoftGSM => MicrosoftGsm,
            ffi::kAudioFormatAES3 => Aes3,
            ffi::kAudioFormatEnhancedAC3 => EnhancedAc3,
            ffi::kAudioFormatFLAC => Flac,
            ffi::kAudioFormatOpus => Opus,
            x => Unknown(x),
        }
    }
}

impl Into<ffi::AudioFormatID> for AudioFormat {
    fn into(self) -> ffi::AudioFormatID {
        use AudioFormat::*;
        match self {
            LinearPcm => ffi::kAudioFormatLinearPCM,
            Ac3 => ffi::kAudioFormatAC3,
            _60958Ac3 => ffi::kAudioFormat60958AC3,
            AppleIma4 => ffi::kAudioFormatAppleIMA4,
            Mpeg4Aac => ffi::kAudioFormatMPEG4AAC,
            Mpeg4Celp => ffi::kAudioFormatMPEG4CELP,
            Mpeg4Hvxc => ffi::kAudioFormatMPEG4HVXC,
            Mpeg4TwinVq => ffi::kAudioFormatMPEG4TwinVQ,
            Mace3 => ffi::kAudioFormatMACE3,
            Mace6 => ffi::kAudioFormatMACE6,
            ULaw => ffi::kAudioFormatULaw,
            ALaw => ffi::kAudioFormatALaw,
            Qdesign => ffi::kAudioFormatQDesign,
            Qdesign2 => ffi::kAudioFormatQDesign2,
            Qualcomm => ffi::kAudioFormatQUALCOMM,
            MpegLayer1 => ffi::kAudioFormatMPEGLayer1,
            MpegLayer2 => ffi::kAudioFormatMPEGLayer2,
            MpegLayer3 => ffi::kAudioFormatMPEGLayer3,
            TimeCode => ffi::kAudioFormatTimeCode,
            MidiStream => ffi::kAudioFormatMIDIStream,
            ParameterValueStream => ffi::kAudioFormatParameterValueStream,
            AppleLossless => ffi::kAudioFormatAppleLossless,
            Mpeg4AacHe => ffi::kAudioFormatMPEG4AAC_HE,
            Mpeg4AacLd => ffi::kAudioFormatMPEG4AAC_LD,
            Mpeg4AacEld => ffi::kAudioFormatMPEG4AAC_ELD,
            Mpeg4AacEldSbr => ffi::kAudioFormatMPEG4AAC_ELD_SBR,
            Mpeg4AacEldV2 => ffi::kAudioFormatMPEG4AAC_ELD_V2,
            Mpeg4AacHeV2 => ffi::kAudioFormatMPEG4AAC_HE_V2,
            Mpeg4AacSpatial => ffi::kAudioFormatMPEG4AAC_Spatial,
            Amr => ffi::kAudioFormatAMR,
            AmrWb => ffi::kAudioFormatAMR_WB,
            Audible => ffi::kAudioFormatAudible,
            Ilbc => ffi::kAudioFormatiLBC,
            DviIntelIma => ffi::kAudioFormatDVIIntelIMA,
            MicrosoftGsm => ffi::kAudioFormatMicrosoftGSM,
            Aes3 => ffi::kAudioFormatAES3,
            EnhancedAc3 => ffi::kAudioFormatEnhancedAC3,
            Flac => ffi::kAudioFormatFLAC,
            Opus => ffi::kAudioFormatOpus,
            Unknown(x) => x,
        }
    }
}

bitflags! {
    /// Flags that are specific to each `AudioFormat`.
    pub struct AudioFormatFlags: ffi::AudioFormatFlags {
        /// Floating point format.
        const IS_FLOAT             = ffi::kAudioFormatFlagIsFloat;
        /// Big endian integer format.
        const IS_BIG_ENDIAN        = ffi::kAudioFormatFlagIsBigEndian;
        /// Signed integer format. This in only valid if `IS_FLOAT` is
        /// not set.
        const IS_SIGNED_INTEGER    = ffi::kAudioFormatFlagIsSignedInteger;
        /// Sample bits occupy the entire available bits for the channel.
        ///
        /// # Note
        ///
        /// Even if this flag is not set, it is implied that this flag
        /// is set if the `AudioStreamBasicDescription` is filled out
        /// such that the fields have the following relationship:
        ///
        /// ```
        /// ((bits_per_sample / 8) * channels_per_frame) == bytes_per_frame
        /// ```
        const IS_PACKED            = ffi::kAudioFormatFlagIsPacked;
        /// Sample bits are placed into the high bits of the
        /// channel. This is only valid if `IS_PACKED` is not set.
        const IS_ALIGNED_HIGH      = ffi::kAudioFormatFlagIsAlignedHigh;
        ///  Set if the samples for each channel are located
        ///  contiguously and the channels are layed out end to end,
        ///  clear if the samples for each frame are layed out
        ///  contiguously and the frames layed out end to end.
        const IS_NON_INTERLEAVED   = ffi::kAudioFormatFlagIsNonInterleaved;
        ///  Indicate when a format is non-mixable.
        ///
        /// # Note
        ///
        /// This flag is only used when interacting with the HAL's
        /// stream format information. It is not a valid flag for any
        /// other uses.
        const IS_NON_MIXABLE       = ffi::kAudioFormatFlagIsNonMixable;
        /// Set if all the flags would be clear in order to preserve 0 as the wild card value.
        const ARE_ALL_CLEAR        = ffi::kAudioFormatFlagsAreAllClear;
        const NATIVE_ENDIAN        = ffi::kAudioFormatFlagsNativeEndian;
        #[cfg(feature = "deprecated")]
        const CANONICAL            = ffi::kAudioFormatFlagsCanonical;
        #[cfg(feature = "deprecated")]
        const AUDIO_UNIT_CANONICAL = ffi::kAudioFormatFlagsAudioUnitCanonical;
    }
}

impl AudioFormatFlags {
    /// Create `AudioFormatFlags` for linear PCM data.
    ///
    /// # Note
    ///
    /// This function does not support specifying sample formats that
    /// are either unsigned integer or low-aligned.
    pub fn with_lpcm_flags(
        valid_bits_per_channel: u32,
        total_bits_per_channel: u32,
        is_float: bool,
        is_big_endian: bool,
        is_non_interleaved: bool,
    ) -> AudioFormatFlags {
        let mut result = if is_float {
            AudioFormatFlags::IS_FLOAT
        } else {
            AudioFormatFlags::IS_SIGNED_INTEGER
        };
        if is_big_endian {
            result |= AudioFormatFlags::IS_BIG_ENDIAN;
        }
        result |= if valid_bits_per_channel == total_bits_per_channel {
            AudioFormatFlags::IS_PACKED
        } else {
            AudioFormatFlags::IS_ALIGNED_HIGH
        };
        if is_non_interleaved {
            result |= AudioFormatFlags::IS_NON_INTERLEAVED;
        }
        result
    }
}

/// Flags specific to `AudioFormat::LinearPcm`
///
/// The linear PCM flags contain a 6-bit bitfield indicating that an
/// integer format is to be interpreted as fixed point. The value
/// indicates the number of bits are used to represent the fractional
/// portion of each sample value.  This constant indicates the bit
/// position (counting from the right) of the bitfield in
/// mFormatFlags.
pub struct LinearPcmFlags(ffi::AudioFormatFlags);

impl LinearPcmFlags {
    const SAMPLE_FRACTION_SHIFT: u32 = ffi::kLinearPCMFormatFlagsSampleFractionShift;
    const SAMPLE_FRACTION_MASK: u32 = ffi::kLinearPCMFormatFlagsSampleFractionMask;

    pub fn number_fractional_bits(&self) -> usize {
        ((self.0 & Self::SAMPLE_FRACTION_MASK) >> Self::SAMPLE_FRACTION_SHIFT) as usize
    }
}

impl From<ffi::AudioFormatFlags> for LinearPcmFlags {
    fn from(x: ffi::AudioFormatFlags) -> Self {
        LinearPcmFlags(x)
    }
}

impl Into<ffi::AudioFormatFlags> for LinearPcmFlags {
    fn into(self) -> ffi::AudioFormatFlags {
        self.0
    }
}

impl AsRef<AudioFormatFlags> for LinearPcmFlags {
    fn as_ref(&self) -> &AudioFormatFlags {
        unsafe { mem::transmute(&self.0) }
    }
}

/// Flags specific to `AudioFormat::AppleLossless`
pub enum AppleLosslessFormatFlags {
    SourceData16Bit = 1,
    SourceData20Bit,
    SourceData24Bit,
    SourceData32Bit,
}

impl Into<ffi::AudioFormatFlags> for AppleLosslessFormatFlags {
    fn into(self) -> ffi::AudioFormatFlags {
        use AppleLosslessFormatFlags::*;
        match self {
            SourceData16Bit => ffi::kAppleLosslessFormatFlag_16BitSourceData,
            SourceData20Bit => ffi::kAppleLosslessFormatFlag_20BitSourceData,
            SourceData24Bit => ffi::kAppleLosslessFormatFlag_24BitSourceData,
            SourceData32Bit => ffi::kAppleLosslessFormatFlag_32BitSourceData,
        }
    }
}

ffi_type_stack! {
    type CType = ffi::AudioStreamBasicDescription;
    /// This structure encapsulates all the information for describing the
    /// basic format properties of a stream of audio data.
    ///
    /// This structure is sufficient to describe any constant bit rate
    /// format that has channels that are the same size. Extensions are
    /// required for variable bit rate data and for constant bit rate data
    /// where the channels have unequal sizes.  However, where applicable,
    /// the appropriate fields will be filled out correctly for these
    /// kinds of formats (the extra data is provided via separate
    /// properties).  In all fields, a value of 0 indicates that the field
    /// is either unknown, not applicable or otherwise is inapproprate for
    /// the format and should be ignored.  Note that 0 is still a valid
    /// value for most formats in the mFormatFlags field.
    ///
    /// In audio data a frame is one sample across all channels. In
    /// non-interleaved audio, the per frame fields identify one
    /// channel. In interleaved audio, the per frame fields identify the
    /// set of n channels. In uncompressed audio, a Packet is one frame,
    /// (`frames_per_packet` == 1). In compressed audio, a Packet is an
    /// indivisible chunk of compressed data, for example an AAC packet
    /// will contain 1024 sample frames.
    pub struct AudioStreamBasicDescription;
    pub struct AudioStreamBasicDescriptionRef;
}

impl AudioStreamBasicDescription {
    /// The format can use any sample rate.
    ///
    /// # Note
    ///
    /// This constant can only appear in listings of supported
    /// formats. It will never appear in a current format.
    pub const ANY_RATE: f64 = ffi::kAudioStreamAnyRate;

    /// Create an `AudioStreamBasicDescription` to describe linear PCM data.
    ///
    /// # Note
    ///
    /// This function does not support specifying sample formats that are either unsigned integer or low-aligned.
    pub fn with_lpcm(
        sample_rate: f64,
        channels_per_frame: u32,
        valid_bits_per_channel: u32,
        total_bits_per_channel: u32,
        is_float: bool,
        is_big_endian: bool,
        is_non_interleaved: bool,
    ) -> Self {
        let flags = AudioFormatFlags::with_lpcm_flags(
            valid_bits_per_channel,
            total_bits_per_channel,
            is_float,
            is_big_endian,
            is_non_interleaved,
        );
        let bytes_per_packet = if is_non_interleaved {
            1
        } else {
            channels_per_frame
        } * (total_bits_per_channel / 8);
        let bytes_per_frame = if is_non_interleaved {
            1
        } else {
            channels_per_frame
        } * (total_bits_per_channel / 8);

        let mut desc = ffi::AudioStreamBasicDescription::default();
        desc.mSampleRate = sample_rate;
        desc.mFormatID = ffi::kAudioFormatLinearPCM;
        desc.mFormatFlags = flags.bits();
        desc.mBytesPerPacket = bytes_per_packet;
        desc.mFramesPerPacket = 1;
        desc.mBytesPerFrame = bytes_per_frame;
        desc.mChannelsPerFrame = channels_per_frame;
        desc.mBitsPerChannel = valid_bits_per_channel;

        AudioStreamBasicDescription::from(desc)
    }
}

impl AudioStreamBasicDescriptionRef {
    #[doc(hidden)]
    fn get_ref(&self) -> &ffi::AudioStreamBasicDescription {
        unsafe { &*self.as_ptr() }
    }

    /// The number of sample frames per second in the stream.
    pub fn sample_rate(&self) -> f64 {
        self.get_ref().mSampleRate
    }

    /// The `AudioFormat` indicating the general kind of data in the stream.
    pub fn format_id(&self) -> AudioFormat {
        AudioFormat::from(self.get_ref().mFormatID)
    }
    /// The `AudioFormatFlags` for the format indicated by `format_id`.
    pub fn format_flags(&self) -> AudioFormatFlags {
        AudioFormatFlags::from_bits_truncate(self.get_ref().mFormatFlags)
    }
    /// The number of bytes in a packet of data.
    pub fn bytes_per_packet(&self) -> u32 {
        self.get_ref().mBytesPerPacket
    }
    /// The number of frames in each packet of data.
    pub fn frames_per_packet(&self) -> u32 {
        self.get_ref().mFramesPerPacket
    }
    /// The number of bytes in a sample frame of data.
    pub fn bytes_per_frame(&self) -> u32 {
        self.get_ref().mBytesPerFrame
    }
    /// The number of channels in each frame of data.
    pub fn channels_per_frame(&self) -> u32 {
        self.get_ref().mChannelsPerFrame
    }
    /// The number of bits of sample data per channel in a frame of data.
    pub fn bits_per_channel(&self) -> u32 {
        self.get_ref().mBitsPerChannel
    }

    pub fn is_native_endian(&self) -> bool {
        self.format_id() == AudioFormat::LinearPcm
            && (self.format_flags() & AudioFormatFlags::IS_BIG_ENDIAN)
                == AudioFormatFlags::NATIVE_ENDIAN
    }
}

ffi_type_stack! {
    type CType = ffi::AudioStreamPacketDescription;
    /// This structure describes the packet layout of a buffer of data
    /// where the size of each packet may not be the same or where
    /// there is extraneous data between packets.
    pub struct AudioStreamPacketDesc;
    pub struct AudioStreamPacketDescRef;
}

impl AudioStreamPacketDescRef {
    #[doc(hidden)]
    #[inline]
    fn get_ref(&self) -> &ffi::AudioStreamPacketDescription {
        unsafe { &*self.as_ptr() }
    }

    /// The number of bytes from the start of the buffer to the
    /// beginning of the packet.
    pub fn start_offset(&self) -> i64 {
        self.get_ref().mStartOffset
    }

    /// The number of sample frames of data in the packet. For formats
    /// with a constant number of frames per packet, this returns 0.
    pub fn variable_frames_in_packet(&self) -> u32 {
        self.get_ref().mVariableFramesInPacket
    }

    /// The number of bytes in the packet.
    pub fn data_byte_size(&self) -> u32 {
        self.get_ref().mDataByteSize
    }
}

//==============================================================================
// Audio Time Stamps

#[repr(u32)]
pub enum SMPTETimeType {
    /// 24 Frame
    _24 = ffi::kSMPTETimeType24,
    /// 25 Frame
    _25 = ffi::kSMPTETimeType25,
    /// 30 Drop Frame
    _30Drop = ffi::kSMPTETimeType30Drop,
    /// 30 Frame
    _30 = ffi::kSMPTETimeType30,
    /// 29.97 Frame
    _2997 = ffi::kSMPTETimeType2997,
    /// 29.97 Drop Frame
    _2997Drop = ffi::kSMPTETimeType2997Drop,
    /// 60 Frame
    _60 = ffi::kSMPTETimeType60,
    /// 59.94 Frame
    _5994 = ffi::kSMPTETimeType5994,
    /// 60 Drop Frame
    _60Drop = ffi::kSMPTETimeType60Drop,
    /// 59.94 Drop Frame
    _5994Drop = ffi::kSMPTETimeType5994Drop,
    /// 50 Frame
    _50 = ffi::kSMPTETimeType50,
    /// 23.98 Frame
    _2398 = ffi::kSMPTETimeType2398,
}

bitflags! {
    pub struct SMPTETimeFlags: ffi::SMPTETimeFlags {
        const UNKNOWN = ffi::kSMPTETimeUnknown;
        const VALID   = ffi::kSMPTETimeValid;
        const RUNNING = ffi::kSMPTETimeRunning;
    }
}

#[derive(Clone, Copy, Debug)]
pub struct SMPTETime(ffi::SMPTETime);
impl SMPTETime {
    pub fn subframes(&self) -> i16 {
        self.0.mSubframes
    }
    pub fn subframe_divisor(&self) -> i16 {
        self.0.mSubframeDivisor
    }
    pub fn counter(&self) -> u32 {
        self.0.mCounter
    }
    pub fn kind(&self) -> SMPTETimeType {
        unsafe { mem::transmute(self.0.mType) }
    }
    pub fn flags(&self) -> SMPTETimeFlags {
        SMPTETimeFlags::from_bits_truncate(self.0.mFlags)
    }
    pub fn hours(&self) -> i16 {
        self.0.mHours
    }
    pub fn minutes(&self) -> i16 {
        self.0.mMinutes
    }
    pub fn seconds(&self) -> i16 {
        self.0.mSeconds
    }
    pub fn frames(&self) -> i16 {
        self.0.mFrames
    }
}

ffi_type_stack! {
    type CType = ffi::AudioTimeStamp;

    pub struct AudioTimeStamp;
    pub struct AudioTimeStampRef;
}

impl AudioTimeStamp {
    pub fn with_sample_time(sample_time: f64) -> AudioTimeStamp {
        AudioTimeStamp(ffi::AudioTimeStamp {
            mSampleTime: sample_time,
            mFlags: ffi::kAudioTimeStampSampleTimeValid,
            ..ffi::AudioTimeStamp::default()
        })
    }

    pub fn with_host_time(host_time: u64) -> AudioTimeStamp {
        AudioTimeStamp(ffi::AudioTimeStamp {
            mHostTime: host_time,
            mFlags: ffi::kAudioTimeStampHostTimeValid,
            ..ffi::AudioTimeStamp::default()
        })
    }

    pub fn with_sample_and_host_time(sample_time: f64, host_time: u64) -> AudioTimeStamp {
        AudioTimeStamp(ffi::AudioTimeStamp {
            mSampleTime: sample_time,
            mHostTime: host_time,
            mFlags: ffi::kAudioTimeStampSampleTimeValid | ffi::kAudioTimeStampHostTimeValid,
            ..ffi::AudioTimeStamp::default()
        })
    }
}

impl AudioTimeStampRef {
    #[doc(hidden)]
    #[inline]
    fn get_ref(&self) -> &ffi::AudioTimeStamp {
        unsafe { &*self.as_ptr() }
    }

    pub fn sample_time(&self) -> Option<f64> {
        if self.get_ref().mFlags & ffi::kAudioTimeStampSampleTimeValid != 0 {
            Some(self.get_ref().mSampleTime)
        } else {
            None
        }
    }

    pub fn host_time(&self) -> Option<u64> {
        if self.get_ref().mFlags & ffi::kAudioTimeStampHostTimeValid != 0 {
            Some(self.get_ref().mHostTime)
        } else {
            None
        }
    }

    pub fn rate_scalar(&self) -> Option<f64> {
        if self.get_ref().mFlags & ffi::kAudioTimeStampRateScalarValid != 0 {
            Some(self.get_ref().mRateScalar)
        } else {
            None
        }
    }

    pub fn word_clock_time(&self) -> Option<u64> {
        if self.get_ref().mFlags & ffi::kAudioTimeStampWordClockTimeValid != 0 {
            Some(self.get_ref().mWordClockTime)
        } else {
            None
        }
    }

    pub fn smpte_time(&self) -> Option<SMPTETime> {
        if self.get_ref().mFlags & ffi::kAudioTimeStampSMPTETimeValid != 0 {
            Some(SMPTETime(self.get_ref().mSMPTETime))
        } else {
            None
        }
    }
}

impl fmt::Debug for AudioTimeStamp {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let mut ds = f.debug_struct("AudioTimeStamp");
        if let Some(sample_time) = self.sample_time() {
            ds.field("sample_time", &sample_time);
        }
        if let Some(host_time) = self.host_time() {
            ds.field("host_time", &host_time);
        }
        if let Some(rate_scalar) = self.rate_scalar() {
            ds.field("rate_scalar", &rate_scalar);
        }
        if let Some(word_clock_time) = self.word_clock_time() {
            ds.field("word_clock_time", &word_clock_time);
        }
        if let Some(smpte_time) = self.smpte_time() {
            ds.field("smpte_time", &smpte_time);
        }
        ds.finish()
    }
}

//==============================================================================
// AudioClassDescription

//==============================================================================
// Audio Channel Layout

/// A tag identifying how the channel is to be used.
#[repr(C)]
#[derive(Clone, Copy, Debug)]
pub struct AudioChannelLabel(ffi::AudioChannelLabel);

impl AudioChannelLabel {
    pub const UNKNOWN: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_Unknown);
    pub const UNUSED: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_Unused);
    pub const USE_COORDINATES: AudioChannelLabel =
        AudioChannelLabel(ffi::kAudioChannelLabel_UseCoordinates);
}

/// A tag identifying a particular pre-defined channel layout.
pub struct StandardChannelLabel {}
impl StandardChannelLabel {
    pub const LEFT: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_Left);
    pub const RIGHT: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_Right);
    pub const CENTER: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_Center);
    pub const LFESCREEN: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_LFEScreen);
    pub const LEFT_SURROUND: AudioChannelLabel =
        AudioChannelLabel(ffi::kAudioChannelLabel_LeftSurround);
    pub const RIGHT_SURROUND: AudioChannelLabel =
        AudioChannelLabel(ffi::kAudioChannelLabel_RightSurround);
    pub const LEFT_CENTER: AudioChannelLabel =
        AudioChannelLabel(ffi::kAudioChannelLabel_LeftCenter);
    pub const RIGHT_CENTER: AudioChannelLabel =
        AudioChannelLabel(ffi::kAudioChannelLabel_RightCenter);
    pub const CENTER_SURROUND: AudioChannelLabel =
        AudioChannelLabel(ffi::kAudioChannelLabel_CenterSurround);
    pub const LEFT_SURROUND_DIRECT: AudioChannelLabel =
        AudioChannelLabel(ffi::kAudioChannelLabel_LeftSurroundDirect);
    pub const RIGHT_SURROUND_DIRECT: AudioChannelLabel =
        AudioChannelLabel(ffi::kAudioChannelLabel_RightSurroundDirect);
    pub const TOP_CENTER_SURROUND: AudioChannelLabel =
        AudioChannelLabel(ffi::kAudioChannelLabel_TopCenterSurround);
    pub const VERTICAL_HEIGHT_LEFT: AudioChannelLabel =
        AudioChannelLabel(ffi::kAudioChannelLabel_VerticalHeightLeft);
    pub const VERTICAL_HEIGHT_CENTER: AudioChannelLabel =
        AudioChannelLabel(ffi::kAudioChannelLabel_VerticalHeightCenter);
    pub const VERTICAL_HEIGHT_RIGHT: AudioChannelLabel =
        AudioChannelLabel(ffi::kAudioChannelLabel_VerticalHeightRight);

    pub const TOP_BACK_LEFT: AudioChannelLabel =
        AudioChannelLabel(ffi::kAudioChannelLabel_TopBackLeft);
    pub const TOP_BACK_CENTER: AudioChannelLabel =
        AudioChannelLabel(ffi::kAudioChannelLabel_TopBackCenter);
    pub const TOP_BACK_RIGHT: AudioChannelLabel =
        AudioChannelLabel(ffi::kAudioChannelLabel_TopBackRight);

    pub const REAR_SURROUND_LEFT: AudioChannelLabel =
        AudioChannelLabel(ffi::kAudioChannelLabel_RearSurroundLeft);
    pub const REAR_SURROUND_RIGHT: AudioChannelLabel =
        AudioChannelLabel(ffi::kAudioChannelLabel_RearSurroundRight);
    pub const LEFT_WIDE: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_LeftWide);
    pub const RIGHT_WIDE: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_RightWide);
    pub const LFE2: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_LFE2);
    pub const LEFT_TOTAL: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_LeftTotal);
    pub const RIGHT_TOTAL: AudioChannelLabel =
        AudioChannelLabel(ffi::kAudioChannelLabel_RightTotal);
    pub const HEARING_IMPAIRED: AudioChannelLabel =
        AudioChannelLabel(ffi::kAudioChannelLabel_HearingImpaired);
    pub const NARRATION: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_Narration);
    pub const MONO: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_Mono);
    pub const DIALOG_CENTRIC_MIX: AudioChannelLabel =
        AudioChannelLabel(ffi::kAudioChannelLabel_DialogCentricMix);

    pub const CENTER_SURROUND_DIRECT: AudioChannelLabel =
        AudioChannelLabel(ffi::kAudioChannelLabel_CenterSurroundDirect);

    pub const HAPTIC: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_Haptic);
}

// first order ambisonic channels
pub struct AmbisonicChannelLabel {}
impl AmbisonicChannelLabel {
    pub const W: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_Ambisonic_W);
    pub const X: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_Ambisonic_X);
    pub const Y: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_Ambisonic_Y);
    pub const Z: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_Ambisonic_Z);
}

// Mid/Side Recording
pub struct MidSideChannelLabel {}
impl MidSideChannelLabel {
    pub const MID: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_MS_Mid);
    pub const SIDE: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_MS_Side);
}

// X-Y Recording
pub struct XyChannelLabel {}
impl XyChannelLabel {
    pub const X: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_XY_X);
    pub const Y: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_XY_Y);
}

// other
pub struct OtherChannelLabel {}
impl OtherChannelLabel {
    pub const HEADPHONES_LEFT: AudioChannelLabel =
        AudioChannelLabel(ffi::kAudioChannelLabel_HeadphonesLeft);
    pub const HEADPHONES_RIGHT: AudioChannelLabel =
        AudioChannelLabel(ffi::kAudioChannelLabel_HeadphonesRight);
    pub const CLICK_TRACK: AudioChannelLabel =
        AudioChannelLabel(ffi::kAudioChannelLabel_ClickTrack);
    pub const FOREIGN_LANGUAGE: AudioChannelLabel =
        AudioChannelLabel(ffi::kAudioChannelLabel_ForeignLanguage);
}

// generic discrete channel
pub struct DiscreteChannelLabel {}
impl DiscreteChannelLabel {
    pub const DISCRETE: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_Discrete);
    pub const DISCRETE_0: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_Discrete_0);
    pub const DISCRETE_1: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_Discrete_1);
    pub const DISCRETE_2: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_Discrete_2);
    pub const DISCRETE_3: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_Discrete_3);
    pub const DISCRETE_4: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_Discrete_4);
    pub const DISCRETE_5: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_Discrete_5);
    pub const DISCRETE_6: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_Discrete_6);
    pub const DISCRETE_7: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_Discrete_7);
    pub const DISCRETE_8: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_Discrete_8);
    pub const DISCRETE_9: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_Discrete_9);
    pub const DISCRETE_10: AudioChannelLabel =
        AudioChannelLabel(ffi::kAudioChannelLabel_Discrete_10);
    pub const DISCRETE_11: AudioChannelLabel =
        AudioChannelLabel(ffi::kAudioChannelLabel_Discrete_11);
    pub const DISCRETE_12: AudioChannelLabel =
        AudioChannelLabel(ffi::kAudioChannelLabel_Discrete_12);
    pub const DISCRETE_13: AudioChannelLabel =
        AudioChannelLabel(ffi::kAudioChannelLabel_Discrete_13);
    pub const DISCRETE_14: AudioChannelLabel =
        AudioChannelLabel(ffi::kAudioChannelLabel_Discrete_14);
    pub const DISCRETE_15: AudioChannelLabel =
        AudioChannelLabel(ffi::kAudioChannelLabel_Discrete_15);
    pub const DISCRETE_65535: AudioChannelLabel =
        AudioChannelLabel(ffi::kAudioChannelLabel_Discrete_65535);
}

pub struct HoaAcnChannelLabel {}
impl HoaAcnChannelLabel {
    pub const HOA_ACN: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_HOA_ACN);
    pub const HOA_ACN0: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_HOA_ACN_0);
    pub const HOA_ACN1: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_HOA_ACN_1);
    pub const HOA_ACN2: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_HOA_ACN_2);
    pub const HOA_ACN3: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_HOA_ACN_3);
    pub const HOA_ACN4: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_HOA_ACN_4);
    pub const HOA_ACN5: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_HOA_ACN_5);
    pub const HOA_ACN6: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_HOA_ACN_6);
    pub const HOA_ACN7: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_HOA_ACN_7);
    pub const HOA_ACN8: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_HOA_ACN_8);
    pub const HOA_ACN9: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_HOA_ACN_9);
    pub const HOA_ACN10: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_HOA_ACN_10);
    pub const HOA_ACN11: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_HOA_ACN_11);
    pub const HOA_ACN12: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_HOA_ACN_12);
    pub const HOA_ACN13: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_HOA_ACN_13);
    pub const HOA_ACN14: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_HOA_ACN_14);
    pub const HOA_ACN15: AudioChannelLabel = AudioChannelLabel(ffi::kAudioChannelLabel_HOA_ACN_15);
    pub const HOA_ACN65024: AudioChannelLabel =
        AudioChannelLabel(ffi::kAudioChannelLabel_HOA_ACN_65024);
}

bitflags! {
    pub struct AudioChannelBitmap: u32 {
        const LEFT = ffi::kAudioChannelBit_Left;
        const RIGHT = ffi::kAudioChannelBit_Right;
        const CENTER = ffi::kAudioChannelBit_Center;
        const LFESCREEN = ffi::kAudioChannelBit_LFEScreen;
        const LEFT_SURROUND = ffi::kAudioChannelBit_LeftSurround;
        const RIGHT_SURROUND = ffi::kAudioChannelBit_RightSurround;
        const LEFT_CENTER = ffi::kAudioChannelBit_LeftCenter;
        const RIGHT_CENTER = ffi::kAudioChannelBit_RightCenter;
        const CENTER_SURROUND = ffi::kAudioChannelBit_CenterSurround;
        const LEFT_SURROUND_DIRECT = ffi::kAudioChannelBit_LeftSurroundDirect;
        const RIGHT_SURROUND_DIRECT = ffi::kAudioChannelBit_RightSurroundDirect;
        const TOP_CENTER_SURROUND = ffi::kAudioChannelBit_TopCenterSurround;
        const VERTICAL_HEIGHT_LEFT = ffi::kAudioChannelBit_VerticalHeightLeft;
        const VERTICAL_HEIGHT_CENTER = ffi::kAudioChannelBit_VerticalHeightCenter;
        const VERTICAL_HEIGHT_RIGHT = ffi::kAudioChannelBit_VerticalHeightRight;
        const TOP_BACK_LEFT = ffi::kAudioChannelBit_TopBackLeft;
        const TOP_BACK_CENTER = ffi::kAudioChannelBit_TopBackCenter;
        const TOP_BACK_RIGHT = ffi::kAudioChannelBit_TopBackRight;
    }
}

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AudioChannelLayoutTag(u32);
impl AudioChannelLayoutTag {
    pub const USE_CHANNEL_DESCRIPTIONS: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_UseChannelDescriptions);
    pub const USE_CHANNEL_BITMAP: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_UseChannelBitmap);
    pub const DISCRETE_IN_ORDER: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_DiscreteInOrder);
    pub const UNKNOWN: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_Unknown);

    pub fn discrete_in_order(channels: u16) -> Self {
        AudioChannelLayoutTag(Self::DISCRETE_IN_ORDER.0 | u32::from(channels))
    }
    pub fn unknown(channels: u16) -> Self {
        AudioChannelLayoutTag(Self::UNKNOWN.0 | u32::from(channels))
    }

    pub fn channels(&self) -> usize {
        (self.0 & 0xFFFF) as _
    }
    pub fn use_channel_descriptions(&self) -> bool {
        *self == Self::USE_CHANNEL_DESCRIPTIONS
    }
    pub fn use_channel_bitmap(&self) -> bool {
        *self == Self::USE_CHANNEL_BITMAP
    }
}

pub struct StandardChannelLayoutTag {}
impl StandardChannelLayoutTag {
    pub const MONO: AudioChannelLayoutTag = AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_Mono);
    pub const STEREO: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_Stereo);
    pub const STEREO_HEADPHONES: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_StereoHeadphones);
    pub const MATRIX_STEREO: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_MatrixStereo);
    pub const MID_SIDE: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_MidSide);
    pub const XY: AudioChannelLayoutTag = AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_XY);
    pub const BINAURAL: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_Binaural);
    pub const AMBISONIC_B_FORMAT: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_Ambisonic_B_Format);
    pub const QUADRAPHONIC: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_Quadraphonic);
    pub const PENTAGONAL: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_Pentagonal);
    pub const HEXAGONAL: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_Hexagonal);
    pub const OCTAGONAL: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_Octagonal);
    pub const CUBE: AudioChannelLayoutTag = AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_Cube);
}

//  MPEG defined layouts
pub struct MpegChannelLayoutTag {}
impl MpegChannelLayoutTag {
    pub const _1_0: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_MPEG_1_0);
    pub const _2_0: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_MPEG_2_0);
    pub const _3_0_A: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_MPEG_3_0_A);
    pub const _3_0_B: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_MPEG_3_0_B);
    pub const _4_0_A: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_MPEG_4_0_A);
    pub const _4_0_B: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_MPEG_4_0_B);
    pub const _5_0_A: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_MPEG_5_0_A);
    pub const _5_0_B: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_MPEG_5_0_B);
    pub const _5_0_C: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_MPEG_5_0_C);
    pub const _5_0_D: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_MPEG_5_0_D);
    pub const _5_1_A: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_MPEG_5_1_A);
    pub const _5_1_B: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_MPEG_5_1_B);
    pub const _5_1_C: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_MPEG_5_1_C);
    pub const _5_1_D: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_MPEG_5_1_D);
    pub const _6_1_A: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_MPEG_6_1_A);
    pub const _7_1_A: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_MPEG_7_1_A);
    pub const _7_1_B: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_MPEG_7_1_B);
    pub const _7_1_C: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_MPEG_7_1_C);
    pub const EMAGIC_DEFAULT_7_1: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_Emagic_Default_7_1);
    pub const SMPTE_DTV: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_SMPTE_DTV);
}

//  ITU defined layouts
pub struct ItuChannelLayoutTag {}
impl ItuChannelLayoutTag {
    pub const _1_0: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_ITU_1_0);
    pub const _2_0: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_ITU_2_0);

    pub const _2_1: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_ITU_2_1);
    pub const _2_2: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_ITU_2_2);
    pub const _3_0: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_ITU_3_0);
    pub const _3_1: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_ITU_3_1);

    pub const _3_2: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_ITU_3_2);
    pub const _3_2_1: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_ITU_3_2_1);
    pub const _3_4_1: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_ITU_3_4_1);
}

// DVD defined layouts
pub struct DvdChannelLayoutTag {}
impl DvdChannelLayoutTag {
    pub const _0: AudioChannelLayoutTag = AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_DVD_0);
    pub const _1: AudioChannelLayoutTag = AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_DVD_1);
    pub const _2: AudioChannelLayoutTag = AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_DVD_2);
    pub const _3: AudioChannelLayoutTag = AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_DVD_3);
    pub const _4: AudioChannelLayoutTag = AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_DVD_4);
    pub const _5: AudioChannelLayoutTag = AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_DVD_5);
    pub const _6: AudioChannelLayoutTag = AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_DVD_6);
    pub const _7: AudioChannelLayoutTag = AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_DVD_7);
    pub const _8: AudioChannelLayoutTag = AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_DVD_8);
    pub const _9: AudioChannelLayoutTag = AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_DVD_9);
    pub const _10: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_DVD_10);
    pub const _11: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_DVD_11);
    pub const _12: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_DVD_12);
    pub const _13: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_DVD_13);
    pub const _14: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_DVD_14);
    pub const _15: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_DVD_15);
    pub const _16: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_DVD_16);
    pub const _17: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_DVD_17);
    pub const _18: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_DVD_18);
    pub const _19: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_DVD_19);
    pub const _20: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_DVD_20);
}

// These layouts are recommended for AudioUnit usage
// These are the symmetrical layouts
pub struct AudioUnitChannelLayoutTag {}
impl AudioUnitChannelLayoutTag {
    pub const _4: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_AudioUnit_4);
    pub const _5: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_AudioUnit_5);
    pub const _6: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_AudioUnit_6);
    pub const _8: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_AudioUnit_8);
    pub const _5_0: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_AudioUnit_5_0);
    pub const _6_0: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_AudioUnit_6_0);
    pub const _7_0: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_AudioUnit_7_0);
    pub const _7_0_FRONT: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_AudioUnit_7_0_Front);
    pub const _5_1: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_AudioUnit_5_1);
    pub const _6_1: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_AudioUnit_6_1);
    pub const _7_1: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_AudioUnit_7_1);
    pub const _7_1_FRONT: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_AudioUnit_7_1_Front);
}

pub struct AacChannelLayoutTag {}
impl AacChannelLayoutTag {
    pub const _3_0: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_AAC_3_0);
    pub const QUADRAPHONIC: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_AAC_Quadraphonic);
    pub const _4_0: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_AAC_4_0);
    pub const _5_0: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_AAC_5_0);
    pub const _5_1: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_AAC_5_1);
    pub const _6_0: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_AAC_6_0);
    pub const _6_1: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_AAC_6_1);
    pub const _7_0: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_AAC_7_0);
    pub const _7_1: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_AAC_7_1);
    pub const _7_1_B: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_AAC_7_1_B);
    pub const _7_1_C: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_AAC_7_1_C);
    pub const OCTAGONAL: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_AAC_Octagonal);
}

pub struct TmhChannelLayoutTag {}
impl TmhChannelLayoutTag {
    pub const _10_2_STD: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_TMH_10_2_std);
    pub const _10_2_FULL: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_TMH_10_2_full);
}

pub struct Ac3ChannelLayoutTag {}
impl Ac3ChannelLayoutTag {
    pub const _1_0_1: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_AC3_1_0_1);
    pub const _3_0: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_AC3_3_0);
    pub const _3_1: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_AC3_3_1);
    pub const _3_0_1: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_AC3_3_0_1);
    pub const _2_1_1: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_AC3_2_1_1);
    pub const _3_1_1: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_AC3_3_1_1);
}

pub struct Eac3ChannelLayoutTag {}
impl Eac3ChannelLayoutTag {
    pub const _6_0_A: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_EAC_6_0_A);
    pub const _7_0_A: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_EAC_7_0_A);
    pub const _6_1_A: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_EAC3_6_1_A);
    pub const _6_1_B: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_EAC3_6_1_B);
    pub const _6_1_C: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_EAC3_6_1_C);
    pub const _7_1_A: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_EAC3_7_1_A);
    pub const _7_1_B: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_EAC3_7_1_B);
    pub const _7_1_C: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_EAC3_7_1_C);
    pub const _7_1_D: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_EAC3_7_1_D);
    pub const _7_1_E: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_EAC3_7_1_E);
    pub const _7_1_F: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_EAC3_7_1_F);
    pub const _7_1_G: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_EAC3_7_1_G);
    pub const _7_1_H: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_EAC3_7_1_H);
}

pub struct DtsChannelLayoutTag {}
impl DtsChannelLayoutTag {
    pub const _3_1: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_DTS_3_1);
    pub const _4_1: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_DTS_4_1);
    pub const _6_0_A: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_DTS_6_0_A);
    pub const _6_0_B: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_DTS_6_0_B);
    pub const _6_0_C: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_DTS_6_0_C);
    pub const _6_1_A: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_DTS_6_1_A);
    pub const _6_1_B: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_DTS_6_1_B);
    pub const _6_1_C: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_DTS_6_1_C);
    pub const _7_0: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_DTS_7_0);
    pub const _7_1: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_DTS_7_1);
    pub const _8_0_A: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_DTS_8_0_A);
    pub const _8_0_B: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_DTS_8_0_B);
    pub const _8_1_A: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_DTS_8_1_A);
    pub const _8_1_B: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_DTS_8_1_B);
    pub const _6_1_D: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_DTS_6_1_D);
}

pub struct HoaChannelLayoutTag {}
impl HoaChannelLayoutTag {
    pub const ACN_SN3D: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_HOA_ACN_SN3D);
    pub const ACN_N3D: AudioChannelLayoutTag =
        AudioChannelLayoutTag(ffi::kAudioChannelLayoutTag_HOA_ACN_N3D);
}

bitflags! {
    pub struct AudioChannelFlags: ffi::AudioChannelFlags {
        const ALL_OFF = ffi::kAudioChannelFlags_AllOff;
        const RECTANGULAR_COORDINATES = ffi::kAudioChannelFlags_RectangularCoordinates;
        const SPHERICAL_COORDINATES = ffi::kAudioChannelFlags_SphericalCoordinates;
        const METERS = ffi::kAudioChannelFlags_Meters;
    }
}

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AudioChannelRectangularCoordinates {
    pub left_right: f32,
    pub back_front: f32,
    pub down_up: f32,
}

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AudioChannelSphericalCoordinates {
    pub azimuth: f32,
    pub elevation: f32,
    pub distance: f32,
}

#[repr(C)]
#[derive(Clone, Copy)]
pub struct AudioChannelDescription {
    pub channel_label: AudioChannelLabel,
    pub channel_flags: AudioChannelFlags,
    coordinates: [f32; 3],
}

/// Describes a single channel.
impl AudioChannelDescription {
    pub fn rectangular_coordinate(&self) -> Option<&AudioChannelRectangularCoordinates> {
        if self.channel_flags
            .contains(AudioChannelFlags::RECTANGULAR_COORDINATES)
        {
            Some(unsafe { mem::transmute(&self.coordinates) })
        } else {
            None
        }
    }

    pub fn spherical_coordinate(&self) -> Option<&AudioChannelSphericalCoordinates> {
        if self.channel_flags
            .contains(AudioChannelFlags::SPHERICAL_COORDINATES)
        {
            Some(unsafe { mem::transmute(&self.coordinates) })
        } else {
            None
        }
    }
}

impl AudioChannelLayoutRef {
    pub fn channel_layout_tag(&self) -> AudioChannelLayoutTag {
        unsafe {
            let acl = &(*self.as_ptr());
            AudioChannelLayoutTag(acl.mChannelLayoutTag)
        }
    }

    pub fn channel_bitmap(&self) -> AudioChannelBitmap {
        unsafe {
            let acl = &(*self.as_ptr());
            AudioChannelBitmap::from_bits_truncate(acl.mChannelBitmap)
        }
    }
}

//==============================================================================
